## Week 4 - Day 1
### Challenges with LDE (Limited Direct Execution)
1) Must restrict access to sensitive state.  
Process could access kernel, other processes, devices  
Access to memory - uses virtual addressing  
Built in page table in cpu that sets a fake address to access actual physical addresses in memory  

* Accessed via %cr3 - cannot be touched by user processes

Process could reconfigure address space restrict access to CPU that controls virtual addressing  
Operations are set inside “rings” of access. CPU restricts access to ring 0 instructions  
User side processes cannot use these instructions, or many of the registers directly. 

#### Virtual Address Space 
* Parts of the address space:
    * Code: binary image of program
    * Data/BSS: Static variables (globals)
    * Heap:explicitlyalloceddata(malloc)
    * Stack: implicitly alloced data
* Kernel mapped into all procs 
    * Often as a per-process stack
        * Called “kstack”
* CPU’s MMU hardware:
    * RemapsVAstoPAs
    * Supportsread-only,kernel-only
    * Detectsaccessesto unmapped regions
    * Physical chip on the CPU that does the look up on the fly. 

Processes run in ring 3 can do most things  
No OS interposition, full performance  
Read/write register, load/store to stack/heap, do math, floating point, call functions  
Syscalls is how it handles filesystem. 

* Cannot be called directly
* Must enter kernel at a well-defined point
* Must raise privilege level to ring 0 so the kernel can run
* The CPU literally makes this changes in access then lowers it back to ring 3 once it is done
* This is done by exceptional control overflow

#### Exceptional Control Flow
Multiple kinds of exceptions  
Async - not linked to a timer, something not linked to the cpu  
Sync - part of the normal execution of the cpu/generated by cpu running - linked to the cpu timer  
Resume - restart on instruction after exception  
Retry: attempt instruction that caused the exception  
Abort: terminate and end program  

* Interrupts - async, resume after executed
    * Network packet arrived, mouse has moved, key pressed, timer fired
* Trap - syn, intentional, resume after executed
    * Executed by cpu as part of its normal function
    * Sys call, breakpoint, overflow
* Fault - sync, unintentional, can retry or abort
    * Div/0, illegal instruction, segment not present,, general protection, FP exception
* Abort - unintentional, aborts 
    * Machine check exception, double fault

Like virtual memory, the CPU stores a table of possible execeptions descriptions in the IDT  
**Interrupt Descriptor Table** - (also known as the Trap Table)  
These are loaded in %idtr - a pointer, accessed by protected lidt instruction  
Interrupts hand off a number for the CPU to know what kind of interrupt it is to look up in the IDT  
This tells the CPU what to do on each type of trap or interrupt  
Cli/sti instructions enable disable interrupts, avoids additional interrupts during a interrupt handling

#### Syscalls
Processes induce syscalls with a trap  
CPU consults its interrupt descriptor table (IDT)  
IDT tells the CPU what code to run on for the interrupt, trap, fault.  
CPU raises privilege level to ring 0  
The kernel sets up the IDT, processes cannot change it  
Opcode passed on stack or in register tells kernel what syscall the process wants to perform.  
Ex: std::cout. Trap is hit, cpu looks up in IDT, moves to ring 0 executes the command to display to terminal  
Modern CPUs have small list of interrupts that send data long with it, that controls use to execute command  
CPU is so fast at handling this, happens a ton every second. This is why when the CPU is loaded it can take several seconds for a character typed to appear, or the mouse to move. 

Program puts the syscall into the registers  
Program executes the trap on the CPU: 

* Switches mode to ring 0
* Switches to process’ kstack
* Pushes process %rip to kstack
* Vectors to trap handler from IDT -> looks up the row in the IDT
* OS syscall dispatch loop gains control

Trap handler uses param to jump to desired handler( fork, exec, etc)  
When syscall is completed, reverses this operation back into ring 3 with a return code in the register

#### Issue 2 - Hardware Sharing
Must prevent denial-of-service; must share hardware  
Process could enter an infinite loop  
Schedule a massive I/O execution  
OS has requirements for multitasking/multiple programs  
Policy and a Mechanism  
Policy: choose what process is run next in a consistent way  
Typically uses a Process Scheduler  
Mechanism: low level code that implants the decision with a dispatcher and context switch  

The OS runs a dispatch loop in an infinite loop

```
While(1) {
    Run process A for some time-slice
    Stop process and save its context
    Load context of another process B
}
```

The OS gets control back from this in several ways.  
Cooperative Multitasking - trust process to relinquish CPU to OS with traps  
However processes can misbehave  
By avoiding all traps and I/o a process can take control of the entire machine  
This is not used modern OSes  

Preemptive Multitasking  
Guarantee OS gets periodic control.  
Enters the OS by enabling a periodic alarm clock  
Hard ware generates a timer interrupt  
User cannot mask timer interrupt