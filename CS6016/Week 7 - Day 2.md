## Week 7 - Day 2
### LINQ
Language Integrated Queries  
`foreach(Game g in Games) // copy of the entire games table` 

1. How do we get such a copy? For now, pretend this doesn’t matter. Assume an in-memory copy of the DB exists
2. Doesn’t this violate “Let SQL Work For You”?


Now that we have scaffolded classes, how do we express something like: Cross product, Natural join, Left join  
Query a database directly in C#: Return C# objects, foreach on the result of the query, Syntax tries to match SQL

Suppose Models contains two classes: Players, Games

```
Var query = // C# variable
from p in db.Players
join g in db.Games
on p.PId equals g.BlackPlayer // on MUST be used. LINQ runs on prior to join
select p;

foreach(Players p in query){...
```

query is an IEnumerable<Players> but LINQ lets us just label query as a var

db is a ChessContext: Auto-generated by scaffolding. This is what allows for LINQ→SQL

With LINQ Controllers

```
using (ChessContext db = new ChessContext())
{
query = from p in db.Players ...
}

query = from p in db.Patrons where p.Name == “Dan” … // where is a C# operator not the SQL one
query = from p in db.Patrons where p.CardNum % 2 == 0 … // LINQ translates to SQL from the C# operator

query =
from p in db.Patrons 
where p.Name.Contains(“a”) orderby p.CardNum
…

query =
from p in db.Patrons
where p.Name.Contains(“a”) orderby p.CardNum descending 
...

query =
from p in db.Patrons
join c in db.CheckedOut
on p.CardNum equals c.CardNum
```


Equals keyword is used in the join / join-on conditional, other places can use ==

We don’t explicitly create a copy of the table in memory  
Write C# code as though there is an in-memory copy of the database  
Automatically translated to SQL queries if/when needed

Selecting Multi Columns

```
query =
from p in db.Patrons
join c in db.CheckedOut
on p.CardNum equals c.CardNum 
select p.Name, c.Serial;
```

LINQ has a hard time figuring out the type of query based on the different returns from p.name and c.Serial.

Option 1 - Create a class - Bad Choice

```
class StringAndInt
{
string s; 
int i; ...
}
```

Option 2 – use a Tuple - Reasonable but limited  
When you need to temporarily create a complex type  
`new Tuple<string, int>(“hi”, 55);`. 
Supports Tuple with up to 8 types:  
`Tuple<int, char, string, int, Student, ...>`  

```
query =
from p in db.Patrons
join c in db.CheckedOut
on p.CardNum equals c.CardNum
select new Tuple<string, int>(p.Name, c.Serial);
```

Option 3 – use an anonymous type - Done in practice most commonly 

``` 
var x = new { 
i = 5,
message = “hello”, 
name = p.Name,
...
};
```

Declare and use within one function; don’t try to pass them around!

```
query =
from p in db.Patrons
join c in db.CheckedOut
on p.CardNum equals c.CardNum
select
new {name = p.Name, serial = c.Serial};

foreach(var x in query) WriteLine(x.name);
```

LINQ Insert

```
Patrons p = new Patrons(); 
p.Name = “Erin”; 
p.CardNum = 5;

db.Patrons.Add(p); 
db.SaveChanges();

```

The SaveChanges(); is needed to actually update the database. Its Lets you do C# and other stuff  
SaveChanges() at the end of the list of adds/deletes it does it in one SQL query making it more efficient  
Set up multiple changes before db.SaveChanges  
Only goes to the database once  
Wrap db.SaveChanges in try/catch to detect errors - Such as duplicate add  

LINQ has no left join keyword (keep all rows of left table, put null on rows where there is no equiv on the right)  
It does a “group join” which has now SQL analog

```
var query =
from t in db.Titles join i in db.Inventory on t.Isbn equals i.Isbn into tJoinI
```

This returns a list of lists

```
{
    {1001, 1002}, // Harry Potter
    {1003}, // Sound and Fury
    {1004, 1005}, // The Lorax
    {1006},// Profiles in Courage
    {}  // Dune
}
```

Now we need to pair each list with a Title

```
from j in tJoinI.DefaultIfEmpty() // DefaultIfEmpty() prevents removing dune as empty and places a null next to it.
select new {t.Title, j.Serial};
```

Turns into single list of tuples: 

```
{
<Harry Potter, 1001>,
<Harry Potter, 1002>,
<Sound and Fury, 1003>,
<The Lorax,  1004>,
<The Lorax, 1005>,
<Profiles in Courage, 1006>, 
<Dune, null>
}
```
Problem: if tJoinI contains some null items, j.Serial throws NullReferenceException

```
if(j == null) null
else j.Serial

select new {t.Title, <Above here>};
```

Use a ternary to accomplish this

```
from j in tJoinI.DefaultIfEmpty() select new {t.Title,
j == null ? (uint?)0 : j.Serial};
```

(Uint?)0 is how 0 can be nullable to allow it to place inside the query